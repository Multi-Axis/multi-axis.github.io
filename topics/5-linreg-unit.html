<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Multi-Axis - Linreg Prediction Unit</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Multi-Axis Documentation</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
            </div>
        </div>
        <div id="content">
            <h1>Linreg Prediction Unit</h1>
            <div class="info">
    
</div>

<p>The <code>linreg</code> unit takes one optional paramater, <code>pre_filter</code>:</p>
<pre><code>&quot;pre_filter&quot; :
     { &quot;aggregate&quot;:      &quot;min&quot; | &quot;max&quot; | &quot;avg&quot;
     , &quot;interval&quot;:       Number
     , &quot;interval_start&quot;: Number 
     }</code></pre>
<p>If this parameter is present then the input data is filtered.</p>
<p><code>interval</code> and <code>interval_start</code> are in seconds; <code>interval</code> marks the length of the interval the filter <code>aggragate</code> function is applied to. So to filter maximum values for every hour youâ€™d say <code>aggregate = &quot;max&quot;</code> and <code>interval = 3600</code>.</p>
<p><code>interval_start</code> specifies interval start <em>boundaries</em>. In other words, it is an offset added to every epoch value before determining the interval it belongs to. So if for example <code>interval_start = 0</code> and <code>interval = 86400</code> (a day) then the timeframe 00:00 - 23:59 (<em>UTC!</em>) form one interval; the boundaries are every midnight (UTC).</p>
<p>To have filter boundaries eg. every day at 6:00 EEST (UTC+03:00), that is, 3:00 UTC, you would have <code>interval_start = -10800</code> and <code>interval = 86400</code>. (<code>3 * 3600 = 10800</code>). Note that <code>interval_start</code> is negative, as it is an offset <em>forward</em> in the original data values to match boundaries.</p>
<p>(Sidenote: <code>interval_start</code> := <code>interval_start</code> modulo <code>interval</code>)</p>
<p>The full filter example:</p>
<pre><code>&quot;pre_filter&quot; :
     { &quot;aggregate&quot;:       &quot;min&quot;
     , &quot;interval&quot;:        86400
     , &quot;interval_start&quot;: -10800 
     }</code></pre>
<p>If, either the first or last interval is <em>incomplete</em> that interval is discarded when doing predictions. An incomplete interval here means that there it has a subinterval at least half the length of the original that has no data points in it.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
